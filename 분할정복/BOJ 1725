문제 번호 : BOJ 1725

solved.ac : platinum 5

알고리즘 분류 : 분할 정복

문제 설명 :
히스토그램에 대해서 알고 있는가? 히스토그램은 아래와 같은 막대그래프를 말한다.  
예를 들어, 왼쪽 그림은 높이가 2, 1, 4, 5, 1, 3, 3이고 너비가 1인 직사각형으로 이루어진 히스토그램이다.  
각 칸의 간격은 일정하고, 높이는 어떤 정수로 주어진다. 위 그림의 경우 높이가 각각 2 1 4 5 1 3 3이다.  
이러한 히스토그램의 내부에 가장 넓이가 큰 직사각형을 그리려고 한다. 아래 그림의 빗금 친 부분이 그 예이다. 이 직사각형의 밑변은 항상 히스토그램의 아랫변에 평행하게 그려져야 한다.  

주어진 히스토그램에 대해, 가장 큰 직사각형의 넓이를 구하는 프로그램을 작성하시오.  


입력 : 
첫 행에는 N (1 ≤ N ≤ 100,000) 이 주어진다. N은 히스토그램의 가로 칸의 수이다. 다음 N 행에 걸쳐 각 칸의 높이가 왼쪽에서부터 차례대로 주어진다.
각 칸의 높이는 1,000,000,000보다 작거나 같은 자연수 또는 0이다.

출력 : 
첫째 줄에 가장 큰 직사각형의 넓이를 출력한다. 이 값은 20억을 넘지 않는다.
---------------------------------------------------------------

문제 풀이 아이디어 : 알고리즘 문제해결전략 참고
해당 문제를 N개의 높이를 보는 것이 아니라 절반으로 나누어 2개의 부분 문제로 살펴본다.
부분 문제를 합쳐서 만든 최대 직사각형은 3가지 경우 중 한 가지에 해당하는데  
1. 가장 큰 직사각형을 왼쪽 부분 문제에서 얻을 수 있다.
2. 가장 큰 직사각형을 오른쪽 부분 문제에서 얻을 수 있다.
3. 가장 큰 직사각형을 왼쪽 부분 문제와 오른쪽 부분 문제를 겹쳐 얻을 수 있다.

위처럼 3가지 경우의 수에 대해 재귀호출을 통해 분할 정복으로 해결하면 된다.

왼쪽과 오른쪽을 절반으로 나누어 탐색하는 것은 재귀 호출을 통해 기저 사례까지 도달하면 쉽게 해결할 수 있으니 생략하고,
3번째 케이스인 영역이 겹쳐 있는 경우에 대해 살펴보자.
경계에 걸쳐 있는 직사각형은 반드시 왼쪽과 오른쪽 영역을 하나씩은 포함하게 되는데,
너비가 2짜리인 2*x 사각형에서 왼쪽 혹은 오른쪽으로 1씩 확장하되, 높이가 커질 수 있는 방향으로 나아가야 한다.
left~right범위내 에서 한단계씩 확장하고, 확장한 것이 사각형의 최대 넓이가 될 수 있는지 확인한다.


시간 복잡도 추론 : 문제를 두 부분으로 나누어 해결하니 NlgN

필요한 자료구조 : 배열

테스트 케이스 :
7
2
1
4
5
1
3
3
-------  
8

코드 : 
#include <bits/stdc++.h>
#define INF 1e9+7
#define pii pair<int,int>
typedef long long ll;

using namespace std;

int N;
ll H[100005]; //히스토그램의 높이를 저장하는 배열 

void input() {
    cin >> N;
    for(int i=0;i<N;i++) {
        cin >> H[i];
    }
}

//가장 큰 사각형을 반환
ll Solve(int left, int right) { 
    if(left == right) return H[left]; //너비가 1일때
    int mid = (left+right) / 2;
    ll res = max(Solve(left,mid), Solve(mid+1,right)); //좌측, 우측 탐색
    
     //좌측과 우측을 포함하는 너비가 2인 사각형 고려
    int lo = mid, hi = mid+1;
    ll height = min(H[lo], H[hi]);
    
    res = max(res,height*2);
    
    //높이가 높은쪽으로 확장
    while(left < lo || hi < right) {
        
        //오른쪽 > 왼쪽 or 왼쪽으로 더 갈 수 없을 때
        if(hi < right && (lo == left || H[lo-1] < H[hi+1])) { 
            hi++;
            height = min(height, H[hi]);
        }
        else { 
            lo--;
            height = min(height, H[lo]);
        }
        res = max(res, height * (hi-lo+1));
    }
    return res;
}

int main() {
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    
    input();
    
    cout << Solve(0,N-1) << "\n";
    
    return 0;
}


원본링크 :
https://www.acmicpc.net/problem/1725

참고 문헌 : 알고리즘 문제해결전략 7.4 울타리 잘라내기 참고

