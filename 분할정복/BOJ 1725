문제 번호 : BOJ 1725

solved.ac : platinum 5

알고리즘 분류 : 분할 정복

문제 설명 :
히스토그램에 대해서 알고 있는가? 히스토그램은 아래와 같은 막대그래프를 말한다.  
예를 들어, 왼쪽 그림은 높이가 2, 1, 4, 5, 1, 3, 3이고 너비가 1인 직사각형으로 이루어진 히스토그램이다.  
![histogram1](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/201006/hist.PNG)  
각 칸의 간격은 일정하고, 높이는 어떤 정수로 주어진다. 위 그림의 경우 높이가 각각 2 1 4 5 1 3 3이다.  
이러한 히스토그램의 내부에 가장 넓이가 큰 직사각형을 그리려고 한다. 아래 그림의 빗금 친 부분이 그 예이다. 이 직사각형의 밑변은 항상 히스토그램의 아랫변에 평행하게 그려져야 한다.  

![histogram2](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/201006/histo.PNG)  

주어진 히스토그램에 대해, 가장 큰 직사각형의 넓이를 구하는 프로그램을 작성하시오.  


입력 : 
첫 행에는 N (1 ≤ N ≤ 100,000) 이 주어진다. N은 히스토그램의 가로 칸의 수이다. 다음 N 행에 걸쳐 각 칸의 높이가 왼쪽에서부터 차례대로 주어진다. 각 칸의 높이는 1,000,000,000보다 작거나 같은 자연수 또는 0이다.

출력 : 
째 줄에 가장 큰 직사각형의 넓이를 출력한다. 이 값은 20억을 넘지 않는다.
---------------------------------------------------------------

나만의 해석 : 

시간 복잡도 추론 : 


문제 풀이 아이디어 : 



필요한 자료구조 : 배열

테스트 케이스 :
7
2
1
4
5
1
3
3
-------  
8

코드 : 
#include <bits/stdc++.h>
#define INF 1e9+7


using namespace std;

int sticky[2][100001];
int dp[2][1000001];
int T, N;

void cal() {
    cin >> N;
    for(int i = 0; i < 2; i++) { //테스트 케이스마다 배열 초기화
        for(int j = 0; j <= 1000000; j++) {
            dp[i][j] = 0;
        }
    }
    sticky[0][0] = 0;
    sticky[1][0] = 0; 
    for(int i = 0; i < 2; i++) { //입력
        for(int j = 1; j <= N; j++) {
            cin >> sticky[i][j];
        }
    }
    dp[0][1] = sticky[0][1];
    dp[1][1] = sticky[1][1];
    for(int j = 2; j <= N; j++) {
        dp[0][j] = max(dp[1][j-1],dp[1][j-2]) + sticky[0][j];
        dp[1][j] = max(dp[0][j-1],dp[0][j-2]) + sticky[1][j];
    }
    int ans = max(dp[0][N],dp[1][N]);
    cout << ans << "\n";
}

void input() {
   cin >> T;
   for(int t = 0;t < T; t++) {
       cal();
   }
}

int main() {
    ios::sync_with_stdio(true); cin.tie(0); cout.tie(0);
    
    input();

    return 0;
}


원본링크 :
https://www.acmicpc.net/problem/9465

참고 문헌 : 

