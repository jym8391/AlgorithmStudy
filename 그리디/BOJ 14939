문제 번호 : BOJ 14939

solved.ac : platinum 4

알고리즘 분류 : 그리디, 브루트포스, 비트마스킹

문제 설명 :
전구 100개가 10×10 정사각형 모양으로 늘어서 있다. 전구에 달린 스위치를 누르면 그 전구와 위, 아래, 왼쪽, 오른쪽에 있는 전구의 상태도 바뀐다.
전구 100개의 상태가 주어지면 모든 전구를 끄기 위해 최소한으로 눌러야 하는 스위치의 개수를 출력하라

입력 : 
10줄에 10글자씩 입력이 주어진다. #은 꺼진 전구고 O(대문자 알파벳 o)는 켜진 전구다. #과 O외에는 입력으로 주어지지 않는다.

출력 : 
모든 전구를 끄기 위해 최소한으로 눌러야 하는 스위치의 개수를 출력하라. 불가능하면 -1를 출력하라.


---------------------------------------------------------------

나만의 해석 : '알고리즘 문제해결전략'에 나오는 순서를 강제할 수 있을까? 부분을 참고함.
불이 켜지고 끄고를 생각했을 때는 2가지의 상태변화가 존재하고 10*10공간이기 때문에
2^100가지를 시도하면 답을 구할 수 있지만 이는 비효율적인 방법이기에 다른 방법을 모색해야 한다.

클릭 수를 최소화하기 위해 살펴볼 것들이 있는데
1. 어떤 순서로 칸들을 클릭하든 상관이 없다. : 각 칸의 상태는 자신과 인접한 칸들의 클릭횟수에 따라 정해지는 것이지 어떤 순서대로 클릭하느냐는 관계가 없다.
2. 한 칸을 두 번 이상 클릭할 필요가 없다. : 같은 칸을 두 번 클릭하는 것은 원래 상태로 돌아오는 것이기 때문에 한 번도 클릭하지 않은 것과 동일하다. 

이 문제를 해결하기 위해서는 한 가지 제약 조건을 추가해야 하는데, "항상 특정 순서대로 칸들을 눌러야 한다."이다.
앞서 살펴본 조건1에서 알 수 있듯이 순서가 상관없기 때문에 제약을 추가한다고 해서 문제의 답이 변하진 않는다. 
대신 첫번째 줄에서 두번째 줄로 넘어왔을 때, 두번째 줄에서 위쪽의 첫번째 꺼져있는 전구를 켜게 된다면, 다시 그 전구를 끌 수 없기 때문에 해당 전구는 클릭하지 않아야 하고,
위쪽의 켜져있는 전구는 지금 끄지 않으면 다시 끌 수 없기 때문에 해당 전구를 클릭해야 함을 알 수 있다.
결국에 위에서부터 전구를 끄도록 순서를 강제할 수 있고, i+1번째 전구의 선택은 i번째 전구들에 의해 이뤄지기 때문에 초기 상태가 존재하지 않는 0번째 전구들만 켜고 끌지를 정해주면 된다.
이 부분은 2^10 = 1024개의 경우의 수를 하나하나 브루트포스 탐색을 진행해주면 된다.

필요한 자료구조 : 배열, string 문자열

테스트 케이스 :
#O########
OOO#######
#O########
####OO####
###O##O###
####OO####
##########
########O#
#######OOO
########O#
------
4

코드 : 
#include <bits/stdc++.h>
#define INF 1e9+7
#define pii pair<int,int>
typedef long long ll;

using namespace std;

/*전구를 전부 끔에 있어서 선택 순서가 결과에 영향을 주진 않음.
위에서부터 전구를 끄도록 순서를 강제할 수 있고, i번째행에서 i+1번째 행으로 넘어가면
i번째 스위치는 더이상 누를 수 없기 때문에 i+1번째행에서 i번째를 꺼야한다.
그러므로 전구를 선택함에 있어서 i+1 행의 수는 i번째 행에 의해 결정됨.
하지만 1번째 행은 이전 행이 없기 때문에 브루트포스를 이용해서 2^10 = 1024개의 경우의 수만 찾아주어
계산을 진행한다면 시간내에 쉽게 해결할 수 있을 것 같다.
*/

bool bulb[10][10];
int dx[4] = {0,0,-1,1};
int dy[4] = {1,-1,0,0};
int ans = INF;


//초기 입력
void input() {
    for(int i=0;i<10;i++) {
        string s;
        cin >> s;
        for(int j=0;j<s.size();j++) {
            if(s[j]=='#') {
                bulb[i][j] = 0;
            }
            else if(s[j]=='O') {
                bulb[i][j] = 1;
            }
        }
    }
}

//브루트포스를 이용하기 위한 임시 배열을 만드는 함수
void arrSet(int arr[10][10]) { 
    for(int i=0;i<10;i++) {
        for(int j=0;j<10;j++) {
            arr[i][j] = bulb[i][j];
        }
    }
}

//전구가 남아있는지 확인 남아있으면 true
bool islight(int arr[10][10]) { 
    for(int i=0;i<10;i++) {
        for(int j=0;j<10;j++) {
            if(arr[i][j]) return true;
        }
    }
    return false;
}

//디버깅용 출력문
void printbulb(int arr[10][10]) { 
    for(int i=0;i<10;i++) {
        for(int j=0;j<10;j++) {
            cout << arr[i][j];
        }
        cout << "\n";
    }
    cout <<"-------------\n\n";
}

//전구 클릭
void press(int arr[10][10],int x,int y) { 

    for(int l=0;l<4;l++) {
        int nx = x + dx[l];
        int ny = y + dy[l];
        if(nx<0||ny<0||nx>9||ny>9) continue; //범위를 벗어난경우
        arr[nx][ny] = !arr[nx][ny]; //상하좌우 반전
    }

    arr[x][y] = !arr[x][y]; //클릭한 곳도 반전
}

void bruteforce() {
    
    int tmp[10][10] = {};
    int cnt;
    
    for(int step=0;step<(1<<10);step++) { //첫번째 행을 결정하는 부분
        arrSet(tmp); //임시 배열 만들기
        cnt = 0;
        for(int bit=0;bit<10;bit++) { //ex) step이 1111011111 이렇게 들어올때 bit번째를 클릭할 수 있는지
            if(step&(1<<bit)) {
                cnt++; //클릭
                press(tmp,0,bit);
            }
        }
        
        //첫줄인 0번째 행은 이미 정하고 왔음으로 1번째행부터 탐색 시작 
        for(int i=1;i<10;i++) {
            for(int j=0;j<10;j++) {
                if(tmp[i-1][j]) { //i-1번째 전구가 켜져있다면
                    cnt++; //클릭
                    press(tmp,i,j);
                }
            }
        }
        
        if(!islight(tmp)) {
            ans = min(ans,cnt);
        }
        //printbulb(tmp);
    }
    if(ans==INF) cout << -1 << "\n";
    else cout << ans << "\n";
}


int main() {
    ios::sync_with_stdio(true); cin.tie(0); cout.tie(0);
    
    input();
    
    bruteforce();
    
    return 0;
}


원본링크 :
https://www.acmicpc.net/problem/14939

참고 문헌 : 
알고리즘 문제해결전략 2.3 문제 해결 전략 p.37  
