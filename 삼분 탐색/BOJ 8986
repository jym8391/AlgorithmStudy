문제 번호 : ㅂBOJ 8986

solved.ac : platinum 5

알고리즘 분류 : 삼분 탐색

문제 설명 :
일직선상에 N개의 전봇대가 한 줄로 서있다. 편의상, 일직선을 x-축이라 하고, 전봇대가 서 있는 위치 x0, x1, ..., xN-1은 x-축 상의 x-좌표라고 하자. x0는 항상 0이고 xi(i ≥ 1)는 양의 정수라고 가정한다.

이 전봇대들을 이웃한 두 전봇대 사이의 거리가 모두 일정하도록 일부 전봇대들을 옮기려고 한다. 이때 이동해야하는 전봇대들의 거리의 합이 최소가 되도록 해야 한다. 단, x0에 위치한 전봇대는 움직일 수 없고, 이동하는 전봇대들은 정수 좌표 위치로만 이동 가능하다. 

전봇대들의 위치 x0, x1, ..., xN-1이 주어지면, 모든 이웃한 전봇대들의 거리가 같도록 전봇대들을 이동할 때(x0에 위치한 전봇대는 고정), 이동 거리의 합이 최소가 되도록 하는 프로그램을 작성하시오.

입력 : 
입력의 첫 줄은 전봇대의 수 N (1 ≤ N ≤ 100,000)이 주어진다. 두 번째 줄에는 전봇대의 위치를 나타내는 N개의 서로 다른 x-좌표 xi(i = 0, ..., N-1)가 빈칸을 사이에 두고 오름차순으로 주어진다. xi는 정수이고, i=0일 때 xi=0, 그 외에는 1 ≤ xi ≤ 1,000,000,000 이다.

출력 : 
출력은 단 한 줄이며, 모든 이웃한 전봇대들의 거리가 같도록 전봇대들의 이동거리 합의 최솟값을 출력한다.


---------------------------------------------------------------

나만의 해석 : '알고리즘 문제해결전략'에서 삼분탐색을 학습하고 문제를 찾아 풀었음.
전봇대 사이의 일정한 거리를 x라고 하면, 전봇대들이 x만큼 유지하기 위해 이동해야하는 총 이동거리 f(x)를 알 수 있는데, x구간이 너무 짧으면 N-1번 방향의 이동거리가 늘어나게 되고, 너무 길게 되도 0번 방향의 이동거리가 늘어나게 된다.
해당 함수 f(x)는 아래로 볼록한 함수로 추측할 수 있는데, x의 값이 정수로 끊기는 만큼 선형형태의 그래프는 아니지만 순감소 후 순증가하고 이 사이에 지역 극대 혹은 극소점(이 문제에서는 극소점)이 존재하기 때문에 삼분 탐색을 활용할 수 있다.



필요한 자료구조 : 벡터

테스트 케이스 :
4
0 4 6 9
--------
1

7
0 5 12 15 16 22 23
---------------------
11

코드 : 
#include <bits/stdc++.h>
#define INF 2e9+7
#define pii pair<int,int>
typedef long long ll;

using namespace std;

int N;
vector<ll> v; //전봇대의 x좌표를 입력받음

void input() {
    cin >> N;
    for(int i=0;i<N;i++) {
        int x;
        cin >> x;
        v.push_back(x);
    }
}

void ternarySearch() { //삼분 탐색
    //전봇대 사이의 거리를 x, f(x) : 전봇대들의 총 이동거리 , 아래로 볼록한 그래프가 형성됨 -> 삼분탐색 활용가능
    ll l = 0, r = v[N-1];

    while(r-l>=3) { //정수 구간이기 때문에 구간 거리가 3개 이상으로 쪼개질때만 탐색함
        ll aab = (2*l + r)/3; //왼쪽 구간
        ll abb = (l + 2*r)/3; //오른쪽 구간
        
        ll sum1 = 0, sum2 = 0; //왼쪽, 오른쪽 구간
        for(int i=0;i<N;i++) {
            sum1 += abs(aab*i-v[i]); 
            sum2 += abs(abb*i-v[i]);
        }
        
        if(sum1<sum2) r = abb; //오른쪽 1/3 날림
        else if(sum1>sum2) l = aab; //왼쪽 1/3 날림
    }
    
    //남은 범위에서 하나씩 탐색하며 최솟값 출력
    ll ans = LLONG_MAX; //거리의 합이 정수 범위를 넘을 수 있기 때문에 long long 가져옴
    for(ll i=l;i<=r;i++) {
        ll S = 0;
        for(int j=0;j<N;j++) {
            S += abs(i*j-v[j]);
        }
        ans = min(ans,S);
    }
    
    cout << ans << "\n";
}


int main() {
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    
    input();
    
    ternarySearch(); 
    
    return 0;
}



원본링크 :
https://www.acmicpc.net/problem/8986

참고 문헌 : 
알고리즘 문제해결전략 13.5 삼분 검색 p.479
