[Gold 4] 12851: 숨바꼭질 2
====================================  
[문제 링크](https://www.acmicpc.net/problem/12851)  

### 알고리즘 분류 :  
너비 우선 탐색

### 시간 제한 :  
2초   

### 문제 설명 :  
수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다.  
수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다.  
순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.  
수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 그리고,  
가장 빠른 시간으로 찾는 방법이 몇 가지 인지 구하는 프로그램을 작성하시오.  

### 입력 :   
첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.  

### 출력 :   
첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.  
둘째 줄에는 가장 빠른 시간으로 수빈이가 동생을 찾는 방법의 수를 출력한다.  

-----------------------------------------------------------  
### 나의 해석 :  
각 위치에서 실행할 수 있는 이동 방법은 두 가지인데,  
1. 현재 위치에서 ±1만큼 이동하기
2. 현재 위치의 2배만큼 이동하기
너비 우선 탐색으로 단계를 하나씩 밟아보고, 목적지까지 도달하는 경우의 수를 세어주면 된다.
처음으로 동생을 만나는 경우, 현재 시간을 기록해주고 다른 경우의 수에서 같은 시간만큼 이동했다면 cnt를 증가시키고
더 짧은 시간 안에 동생을 만났다면 최단 시간을 갱신해주고, cnt도 0부터 다시 증가시키면 된다.


***중요***
for문을 탐색하며 큐에 원소를 넣을 때 visited 또한 true로 만드는 경우가 있는데,  
최단 경로의 개수를 구해야하는 문제이므로, 현재 경로가 아닌 다른 경로에서도 방문할 수도 있기 때문에  
큐에서 pop하고나서 방문 배열을 true로 만들어주어야 한다.   

### 참고 문헌 :  
https://velog.io/@yoohoo030/%EB%B0%B1%EC%A4%8012851-%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88-2-C  
