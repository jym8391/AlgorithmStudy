분할 정복 : 문제를 둘 이상의 부분 문제(subproblem)으로 나눈 뒤 각 문제에 대한 답을 재귀 호출을 이용해 계산하고, 각 부분 문제의 답을 이용해 전체 문제의 답을 계산한다.
재귀 호출과의 차이점 : 거의 같은 크기의 부분 문제로 나눈다.

분할 정복 구성요소 3가지
1. divide : 문제를 더 작은 문제로 분할하는 과정
2. merge : 각 문제에 대해 구한 답을 원래 문제에 대한 답으로 병합하는 과정
3. base case : 더 이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제

장점 : 같은 작업을 더 빠르게 처리해준다. 
ex. 행렬의 빠른 제곱
n*n 크기의 행렬 A가 주어질 때 A^m은 A를 연속해서 m번 곱한 것인데,
m이 커질수록 O(n^3)의 시간이 걸린다. 하지만 분할 정복을 이용하면 lgn시간 만에 계산할 수 있다.

관련 문제 : BOJ 10830번 행렬 제곱

ex. 카라츠바의 빠른 곱셈 알고리즘
수백~수만 자리 되는 큰 숫자들을 다룰 때 사용
기존에는 정수를 정수형 배열에 입력받아 A[i]와 B[i]의 곱을 C[i+j]에 저장하여 코드를 작성
카라츠바 빠른 곱셈 알고리즘은 두 수 a, b를 각각 절반으로 쪼갠다.
a, b가 각각 256자리라면 a1, b1은 첫 128자리, a0, b0는 그 다음 128자리를 저장하도록 한다. 
그렇다면
a = a1 * 10^128 + a0
b = b1 * 10^128 + b0 가 된다. 
a*b는 네 조각으로 나뉘게 되어
a * b = (a1 * 10^128 + a0) * (b1 * 10^128 + b0)
      = a1 * b1 * 10^256 + (a1*b0 + a0*b1) * 10^128 + a0 * b0 가 된다.

그렇게 되면 길이가 n인 두 정수를 곱하는 데 드는 시간은 덧셈과 시프트 연산에 걸리는 시간 O(n)과 
n/2 길이 조각들의 곱셈 4번으로 나눌 수 있게 된다. 하지만 이는 전체 수행 시간이 O(n^2)이 된다는 사실을 증명할 수 있어,
기존의 시간 복잡도와 큰 차이가 없다.

카라츠바는 위의 식을 4번이 아닌 3번만으로 계산할 수 있다고 하였는데,
위의 계수들을 z2,z1,z0이라고 쓰면, a * b = z2 * 10^256 + z1 * 10^128 + z0 이 된다.
(a0 + a1) * (b0 * b1) = z0 + z1 + z2 이므로, 위의 식의 결과에서 z0,z2를 빼서 z1을 구할 수 있다.

z2 = a1 * b1;
z1 = a0 * b0;
z3 = (a0 + a1) - (b0 + b1) - z0 - z2;

시간 복잡도 분석
두 개의 입력을 절반으로 쪼개고, 세 번의 재귀 호출을 한다.
자릿수 n이 2의 거듭제곱 k라고 했을 때, 거듶 제곱의 깊이는 k가 된다. 한번의 분할마다 곱셈이 3번 있기 때문에 3^k의 부분 문제가 있기 때문에
곱셈의 수는 O(3^k)가 된다.
n = 2^k라고 가정했으니 k = lgn이고
O(3^k) = O(n^lg3)이 된다.

ex. 울타리 잘라내기(난이도 : 중)
문제를 두 개의 분할 문제로 만들어
1. 왼쪽에서 가장 큰 직사각형 잘라내기
2. 오른쪽에서 가장 큰 직사각형 잘라내기
3. 왼쪽과 오른쪽에 걸친 부분에 가장 큰 직사각형 잘라내기
이렇게 3가지로 재귀호출하여 해결할 수 있다.

정당성 증명
각 단계마다 더 높은 판자를 택하는 것이 항상 옳은 이유
귀류법을 통해 증명가능
왼쪽 혹은 오른쪽으로 값을 늘려나갈 때, 어느 한쪽이든 너비가 결국 같은 크기로 증가하게 되는데, 높이가 낮은 쪽으로 가게 되면 큰 쪽으로 가게 된 것보다
절대 큰 직사각형이 나올 수 없기 때문

이 문제는 상호 배타적 집합을 이용해서도 풀 수 있다. 
모든 판자들이 없다고 가정하고 높이를 오름차순으로 하나하나 문제에 추가해나가며 서로 연결된 판자들의 집합을 유지하는 것으로 확인가능하다.

ex. 팬미팅(난이도 : 상)
남자 멤버는 남자 팬과 포옹 대신 악수를 하는데, 멤버 전부가 포옹을 하는 경우를 구하시오.
이 문제를 빠르게 풀기 위해서는 문제를 큰 수의 곱셈으로 변환하여 푸는 것인데
큰 정수 N,M을 곱하는 과정을 살펴보고, 3자리수 A와 큰 정수 B의 곱을 각 자릿수를 Ci,Ci-1,...C1,C0라고 표현한다면, 
Ci = A0*Bi + A1*Bi-1 + A0*Bi-2 의 형태를 가짐을 알 수 있다.
A의 숫자들을 왼쪽으로 한칸씩 움직이면서,B에 해당하는 숫자와의 곱한 결과를 알 수 있게 되는데
남성을 1, 여성을 0이라고 표현하면 여성을 만났을 때 두 수의 곱은 항상 0이 되고, 남자끼리만 만났을 때 1이 되기 때문에
1이 되는 경우는 악수, 여성의 경우는 포옹으로 표현할 수 있게 된다.
따라서 모든 Ci가 0이라면 모든 멤버가 포옹을 함을 알 수 있게 된다.
이는 위의 카라츠바 알고리즘을 이용해서 코드를 작성할 수 있다.