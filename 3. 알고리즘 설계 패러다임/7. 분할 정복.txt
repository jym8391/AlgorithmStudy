분할 정복 : 문제를 둘 이상의 부분 문제(subproblem)으로 나눈 뒤 각 문제에 대한 답을 재귀 호출을 이용해 계산하고, 각 부분 문제의 답을 이용해 전체 문제의 답을 계산한다.
재귀 호출과의 차이점 : 거의 같은 크기의 부분 문제로 나눈다.

분할 정복 구성요소 3가지
1. divide : 문제를 더 작은 문제로 분할하는 과정
2. merge : 각 문제에 대해 구한 답을 원래 문제에 대한 답으로 병합하는 과정
3. base case : 더 이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제

장점 : 같은 작업을 더 빠르게 처리해준다. 
ex. 행렬의 빠른 제곱
n*n 크기의 행렬 A가 주어질 때 A^m은 A를 연속해서 m번 곱한 것인데,
m이 커질수록 O(n^3)의 시간이 걸린다. 하지만 분할 정복을 이용하면 lgn시간 만에 계산할 수 있다.

관련 문제 : BOJ 10830번 행렬 제곱

ex. 카라츠바의 빠른 곱셈 알고리즘
수백~수만 자리 되는 큰 숫자들을 다룰 때 사용
기존에는 정수를 정수형 배열에 입력받아 A[i]와 B[i]의 곱을 C[i+j]에 저장하여 코드를 작성
카라츠바 빠른 곱셈 알고리즘은 두 수 a, b를 각각 절반으로 쪼갠다.
a, b가 각각 256자리라면 a1, b1은 첫 128자리, a0, b0는 그 다음 128자리를 저장하도록 한다. 
그렇다면
a = a1 * 10^128 + a0
b = b1 * 10^128 + b0 가 된다. 
a*b는 네 조각으로 나뉘게 되어
a * b = (a1 * 10^128 + a0) * (b1 * 10^128 + b0)
      = a1 * b1 * 10^256 + (a1*b0 + a0*b1) * 10^128 + a0 * b0 가 된다.

그렇게 되면 길이가 n인 두 정수를 곱하는 데 드는 시간은 덧셈과 시프트 연산에 걸리는 시간 O(n)과 
n/2 길이 조각들의 곱셈 4번으로 나눌 수 있게 된다. 하지만 이는 전체 수행 시간이 O(n^2)이 된다는 사실을 증명할 수 있어,
기존의 시간 복잡도와 큰 차이가 없다.

카라츠바는 위의 식을 4번이 아닌 3번만으로 계산할 수 있다고 하였는데,
위의 계수들을 z2,z1,z0이라고 쓰면, a * b = z2 * 10^256 + z1 * 10^128 + z0 이 된다.
(a0 + a1) * (b0 * b1) = z0 + z1 + z2 이므로, 위의 식의 결과에서 z0,z2를 빼서 z1을 구할 수 있다.

z2 = a1 * b1;
z1 = a0 * b0;
z3 = (a0 + a1) - (b0 + b1) - z0 - z2;

시간 복잡도 분석
두 개의 입력을 절반으로 쪼개고, 세 번의 재귀 호출을 한다.
자릿수 n이 2의 거듭제곱 k라고 했을 때, 거듶 제곱의 깊이는 k가 된다. 한번의 분할마다 곱셈이 3번 있기 때문에 3^k의 부분 문제가 있기 때문에
곱셈의 수는 O(3^k)가 된다.
n = 2^k라고 가정했으니 k = lgn이고
O(3^k) = O(n^lg3)이 된다.