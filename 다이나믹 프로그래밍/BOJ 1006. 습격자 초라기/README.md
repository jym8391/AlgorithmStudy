[Platinum 3] 1006: 습격자 초라기
====================================  
[문제 링크](https://www.acmicpc.net/problem/1006)  

### 알고리즘 분류 :  
다이나믹 프로그래밍  

### 시간 제한 :  
2초   

### 문제 설명 :  
초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다.  
원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다.  
(그림의 숫자는 각 구역의 번호이다.)  

<p align="center">
<img src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/201003/dfck3232_34g7t9f4gp_b.jpg"> 
</p>   

초라기는 각각 W명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 특수소대를 아래 조건에 따라 침투 시킬 수 있다.

1. 한 특수소대는 침투한 구역 외에, 인접한 한 구역 더 침투할 수 있다. (같은 경계를 공유하고 있으면 인접 하다고 한다.  
   위 그림에서 1구역은 2, 8, 9 구역과 서로 인접한 상태다.) 즉, 한 특수소대는 한 개 혹은 두 개의 구역을 커버할 수 있다.
3. 특수소대끼리는 아군인지 적인지 구분을 못 하기 때문에, 각 구역은 하나의 소대로만 커버해야 한다.
4. 한 특수소대가 커버하는 구역의 적들의 합은 특수소대원 수 W 보다 작거나 같아야 한다.
  
이때 초라기는 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 알고 싶어 한다.  

### 입력 :   
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어있다.  
첫째 줄에는 (구역의 개수)/2 값 N과 특수 소대원의 수 W가 주어진다. (1 ≤ N ≤ 10000, 1 ≤ W ≤ 10000).  
둘째 줄에는 1~N번째 구역에 배치된 적의 수가 주어지고, 셋째 줄에는 N+1 ~ 2N번째 구역에 배치된 적의 수가 공백으로 구분되어 주어진다. (1 ≤ 각 구역에 배치된 최대 적의 수 ≤ 10000)  
단, 한 구역에서 특수 소대원의 수보다 많은 적이 배치된 구역은 존재하지 않는다. (따라서, 각 구역에 배치된 최대 적의 수 ≤ W)  

### 출력 :   
각 테스트케이스에 대해서 한 줄에 하나씩 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 출력하시오.  

-----------------------------------------------------------  
### 나의 해석 :  
환형 배열을 선형 배열로 만들어서 푸는 로직이 필요하다.  
기본적으로는 2*N타일링 문제라고 봐도 무방하다.  

먼저 환형이 아닌 선형이라고 가정하고 문제를 풀어보자.  
1. dp[i][0] : i열까지 아래만 소대를 배치하기  
2. dp[i][1] : i열까지 위만 소대를 배치하기 
3. dp[i][2] : i-1열까지 위아래로 소대를 배치하기
   
라고 배열을 정의하자. 

i번째 열을 기준으로
한쪽이 담당된 상태에서 반대편에 소대 하나를 투입하는 경우 : dp[i+1][2] = min(dp[i][0] + 1, dp[i][1] + 1);   
두 개의 소대가 각각 가로로 2구역씩 담당하는 경우(= 모양) : dp[i+1][2] = min(dp[i+1][2], dp[i-1][2] + 2);   
하나의 소대가 세로로 2구역을 담당하는 경우(|모양) :  dp[i+1][2] = min(dp[i+1][2], dp[i][2] + 1);   

i==N이 아니라면  
dp[i+1][0] = dp[i+1][2] + 1;  
dp[i+1][1] = dp[i+1][2] + 1;  
로 다음 i+1번째 열에 대해 dp배열 값을 증가시켜 준다.  
i까지 꽉차있는 상태에서 소대를 하나 추가시켜주는 경우도 있지만,  
i-1까지만 꽉차있고 하나의 소대만 추가되어 있는 경우라면 그 반대편에 가로로 2구역(-모양)을 담당하는 소대 하나를 추가할 수 있다.  
i번째 1행에서 -로 하나의 소대가 가로로 2구역을 담당하는 경우 : dp[i+1][0] = min(dp[i+1][0],dp[i][1]+1);   
i번째 0행에서 -로 하나의 소대가 가로로 2구역을 담당하는 경우 : dp[i+1][1] = min(dp[i+1][1],dp[i][0]+1);  

선형을 해결하기 위한 점화식은 모두 구성했는데, 이를 어떻게 환형으로 해결할까?  
선형으로 풀었다는 이야기는 첫번째 열과 마지막 열이 연결되어 있지 않다는 것이다.  
환형의 경우 4가지 형태로 구성되는데
1. 아무것도 연결이 되지 않은 경우(선형)
2. 위쪽만 연결된 경우
3. 아래쪽만 연결된 경우
4. 둘다 연결되어있는 경우

이렇게 총 4가지로 연결지을 수 있다.  
위 4가지를 dp를 구성한 후 최솟값을 찾아 값을 연결지어주면 된다.  
1번과 N번을 연결하는 것이기 때문에 값을 연결지은 후에는 2번부터 다시 탐색을 시작하면 된다.  

### 참고 문헌 :  
https://kibbomi.tistory.com/128  
