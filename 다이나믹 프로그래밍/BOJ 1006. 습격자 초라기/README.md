[Platinum 3] 1006: 습격자 초라기
====================================  
[문제 링크](https://www.acmicpc.net/problem/1006)  

### 알고리즘 분류 :  
다이나믹 프로그래밍  

### 시간 제한 :  
2초   

### 문제 설명 :  
초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다.  
원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다.  
(그림의 숫자는 각 구역의 번호이다.)  

<p align="center">
<img src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/201003/dfck3232_34g7t9f4gp_b.jpg"> 
</p>   

초라기는 각각 W명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 특수소대를 아래 조건에 따라 침투 시킬 수 있다.

1. 한 특수소대는 침투한 구역 외에, 인접한 한 구역 더 침투할 수 있다. (같은 경계를 공유하고 있으면 인접 하다고 한다.  
   위 그림에서 1구역은 2, 8, 9 구역과 서로 인접한 상태다.) 즉, 한 특수소대는 한 개 혹은 두 개의 구역을 커버할 수 있다.
3. 특수소대끼리는 아군인지 적인지 구분을 못 하기 때문에, 각 구역은 하나의 소대로만 커버해야 한다.
4. 한 특수소대가 커버하는 구역의 적들의 합은 특수소대원 수 W 보다 작거나 같아야 한다.
  
이때 초라기는 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 알고 싶어 한다.  

### 입력 :   
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어있다.  
첫째 줄에는 (구역의 개수)/2 값 N과 특수 소대원의 수 W가 주어진다. (1 ≤ N ≤ 10000, 1 ≤ W ≤ 10000).  
둘째 줄에는 1~N번째 구역에 배치된 적의 수가 주어지고, 셋째 줄에는 N+1 ~ 2N번째 구역에 배치된 적의 수가 공백으로 구분되어 주어진다. (1 ≤ 각 구역에 배치된 최대 적의 수 ≤ 10000)  
단, 한 구역에서 특수 소대원의 수보다 많은 적이 배치된 구역은 존재하지 않는다. (따라서, 각 구역에 배치된 최대 적의 수 ≤ W)  

### 출력 :   
각 테스트케이스에 대해서 한 줄에 하나씩 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 출력하시오.  

-----------------------------------------------------------  
### 나의 해석 :  
환형 배열을 선형 배열로 만들어서 푸는 로직이 필요하다.  
기본적으로는 2*N타일링 문제라고 봐도 무방하다.  
1. dp[i][0] : i까지 아래만 소대를 배치하기  
2. dp[i][1] : i까지 위만 소대를 배치하기 
3. dp[i][2] : i-1까지만 소대를 배치하기
  
라고 배열을 정의하자. 

1개의 구역에 1개의 소대만 추가하는 경우에는 dp[i+1][2] = min(dp[i][0] + 1, dp[i][1] + 1) 이다.   
이미 배치된 구역에 대해 인접 구역은 고려하지 않았다.    

인접 배치 구역을 고려하는 경우  
두 개의 소대가 각각 가로로 2구역씩 담당하는 경우(= 모양) : dp[i+1][2] = min(dp[i+1][2], dp[i-1][2] + 2);   
하나의 소대가 세로로 2구역을 담당하는 경우(|모양) :  dp[i+1][2] = min(dp[i+1][2], dp[i][2] + 1);   

i-1까지 모두 채운다는 것은 dp[i][2]에서 소대를 하나 더 배치하는 것과 동일하다. 따라서,  
dp[i+1][0] = dp[i+1][2] + 1;  
dp[i+1][1] = dp[i+1][2] + 1;  

위의 과정을 거친 후 하나의 소대가 가로로 2구역을 담당하는 경우  
dp[i+1][0] = min(dp[i+1][0],dp[i][1]+1);   
dp[i+1][1] = min(dp[i+1][1],dp[i][0]+1);   
위처럼 점화식을 구성할 수 있다.  
