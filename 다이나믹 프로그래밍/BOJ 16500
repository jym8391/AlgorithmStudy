문제 번호 : BOJ 16500

solved.ac : gold 5

알고리즘 분류 : 다이나믹 프로그래밍

문제 설명 :
알파벳 소문자로 이루어진 문자열 S와 단어 목록 A가 주어졌을 때, S를 A에 포함된 문자열을 한 개 이상 공백없이 붙여서 만들 수 있는지 없는지 구하는 프로그램을 작성하시오. A에 포함된 단어를 여러 번 사용할 수 있다.

입력 : 
첫째 줄에 길이가 100이하인 문자열 S가 주어진다. 둘째 줄에는 A에 포함된 문자열의 개수 N(1 ≤ N ≤ 100)이 주어진다. 셋째 줄부터 N개의 줄에는 A에 포함된 단어가 한 줄에 하나씩 주어진다.
A에 포함된 문자열은 알파벳 소문자로만 이루어져 있고, 길이는 100을 넘지 않는다.

모든 학생들은 집에서 X에 갈수 있고, X에서 집으로 돌아올 수 있는 데이터만 입력으로 주어진다.

출력 : 
A에 포함된 문자열로 S를 만들 수 있으면 1, 없으면 0을 출력한다.


---------------------------------------------------------------

나만의 해석 : 
dp[i]를 i-1번째 인덱스까지 문자열을 A에 포함되는 문자열을 만들 수 있는지 여부 결정
단어 목록을 사전순, 길이 순으로 정렬한 뒤 각 단어를 하나씩 넣으면서 dp의 초깃값을 설정해준다.
그 뒤 반복문을 통해 dp[i]가 true라면, N개의 단어를 넣어보면서 s[i]에서 시작되는 문자열이 j번째 단어와 일치한다면, dp[i+arr[j].length()] = true로 설정하여,
해당 인덱스까지는 만들 수 있음을 표현하며 상향식으로 진행하며 최종적으로 dp[s.lenght()]가 true인지 여부를 판별하면 된다.


필요한 자료구조 : 배열, 문자열

테스트 케이스 :
softwarecontest
2
software
contest
---------
1

코드 : 
#include <bits/stdc++.h>

using namespace std;

string s;
string arr[101];
int dp[1001]; //i-1번째까지 문자열을 s(A)에 포함시킬 수 있는지

int N;

bool cmp(const string &a,const string &b) {
    return a.length() > b.length();
}

void input() {
    
    cin >> s;
    
    cin >> N;
    
    for(int i=0;i<N;i++) {
        cin >> arr[i];
    }
    
    sort(arr,arr+N,cmp);
    
}


int main() {
    ios::sync_with_stdio(true); cin.tie(0); cout.tie(0);
    
    input();
    
    for(int i = 0; i < N; i++) {
        bool flag = true;
        for(int j = 0; j < arr[i].length(); j++) {
            if(s[j] != arr[i][j]) { //불일치
                flag = false;
                break;
            }
        }
        if(flag) dp[arr[i].length()] = true;
    }
    
    
    for(int i = 0; i < s.length(); i++) {
        if(dp[i]) {
            for(int j = 0; j < N; j++) {
                bool flag = true;
                for(int k = 0; k < arr[j].length(); k++) {
                    if(s[i+k] != arr[j][k]) { //불일치
                        flag = false;
                        break;
                    }
                }
                if(flag) dp[i+arr[j].length()] = true;
            }
        }
    }
    
    cout << dp[s.length()] << "\n";
    
    return 0;
}

원본링크 :
https://www.acmicpc.net/problem/16500

참고 문헌 : 
X
