문제 번호 : BOJ 1865

solved.ac : gold 3

알고리즘 분류 : 최단 경로, 벨만-포드

문제 설명 :
때는 2020년, 백준이는 월드나라의 한 국민이다. 월드나라에는 N개의 지점이 있고 N개의 지점 사이에는 M개의 도로와 W개의 웜홀이 있다. (단 도로는 방향이 없으며 웜홀은 방향이 있다.)
웜홀은 시작 위치에서 도착 위치로 가는 하나의 경로인데, 특이하게도 도착을 하게 되면 시작을 하였을 때보다 시간이 뒤로 가게 된다. 웜홀 내에서는 시계가 거꾸로 간다고 생각하여도 좋다.

시간 여행을 매우 좋아하는 백준이는 한 가지 궁금증에 빠졌다. 한 지점에서 출발을 하여서 시간여행을 하기 시작하여 다시 출발을 하였던 위치로 돌아왔을 때, 출발을 하였을 때보다 시간이 되돌아가 있는 경우가 있는지 없는지 궁금해졌다.
여러분은 백준이를 도와 이런 일이 가능한지 불가능한지 구하는 프로그램을 작성하여라.

입력 : 
첫 번째 줄에는 테스트케이스의 개수 TC(1 ≤ TC ≤ 5)가 주어진다. 그리고 두 번째 줄부터 TC개의 테스트케이스가 차례로 주어지는데 
테스트케이스의 첫 번째 줄에는 지점의 수 N(1 ≤ N ≤ 500), 도로의 개수 M(1 ≤ M ≤ 2500), 웜홀의 개수 W(1 ≤ W ≤ 200)이 주어진다.
그리고 두 번째 줄부터 M+1번째 줄에 도로의 정보가 주어지는데 각 도로의 정보는 S, E, T 세 정수로 주어진다. S와 E는 연결된 지점의 번호, T는 이 도로를 통해 이동하는데 걸리는 시간을 의미한다.
그리고 M+2번째 줄부터 M+W+1번째 줄까지 웜홀의 정보가 S, E, T 세 정수로 주어지는데 S는 시작 지점, E는 도착 지점, T는 줄어드는 시간을 의미한다. T는 10,000보다 작거나 같은 자연수 또는 0이다.

두 지점을 연결하는 도로가 한 개보다 많을 수도 있다. 지점의 번호는 1부터 N까지 자연수로 중복 없이 매겨져 있다.

출력 : 
첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.TC개의 줄에 걸쳐서 만약에 시간이 줄어들면서 출발 위치로 돌아오는 것이 가능하면 YES, 불가능하면 NO를 출력한다.
---------------------------------------------------------------

나만의 해석 : 그래프 탐색, 벨만 포드

시간 복잡도 추론 : ㅁ?ㄹ


문제 풀이 아이디어 : 
음수 간선이 존재하기 때문에 다익스트라 알고리즘을 활용할 수 없음.
간선의 수가 많기 때문에 플로이드 와샬은 못쓸거 같으니, 벨만 포드 알고리즘을 활용
0. 음수 가중치가 존재하기 때문에 벨만-포드 알고리즘 활용
1. 도로는 무방향이므로 양방향 간선 2개 추가
2. 웜홀은 가중치는 음수로

3. 모든 정점에서 음의 사이클을 확인해야 하는가?
->음수 사이클 여부는 어느점에서 시작하든 확인할 수 있음을 알 수 있음.

4.dist[from] != INF 
->INF인 경우 뒤에 있는 사이클을 판단할 수 없게 된다. INF를 확인하는 이유는 단절을 확인하기 위함인데,
모든 노드들이 연결된 상태가 아닐 수도 있기 때문에(연결 그래프X), 특정 노드들이 단절되어 있고 해당 노드들끼리 사이클을 형성했다면 문제에서 원하는 1->1 사이클은 확인할 수 없다.




필요한 자료구조 : 배열, 벡터

테스트 케이스 :
2
3 3 1
1 2 2
1 3 4
2 3 1
3 1 3
3 2 1
1 2 3
2 3 4
3 1 8
------
NO
YES

1
6 5 1
1 6 1
6 2 1
2 3 1
3 4 1
4 5 1
5 3 1
------
NO


코드 : 
#include <bits/stdc++.h>
#define pii pair<int,int>
#define INF 1e9+7
using namespace std;

int TC; //테스트 케이스의 수
int N, M, W, S, E, T;; //정점, 도로, 웜홀 수, 출발, 도착, 시간
int dist[501]; //1->to까지의 거리
void input() {

    cin >> TC;
    
    for(int t=0;t<TC;t++) {
        cin >> N >> M >> W;
        vector<pii> v[505]; //i->j(first), cost(second)
        for(int j = 0; j < M; j++) { //도로 입력
            cin >> S >> E >> T;
			v[S].push_back({E,T});
			v[E].push_back({S,T});
        }
        for(int j = 0; j < W; j++) { //웜홀 입력
            cin >> S >> E >> T;
			v[S].push_back({E,-T});
        }
        //1번을 출발지점으로 삼을거니까 1->1은 거리가 0이라고 설정하고 시작
        for (int i = 2; i <= N; i++) dist[i] = INF;
        dist[1] = 0;
        
        bool cycle = false; //1->1으로 오는 사이클 판단 변수
        
        for(int i = 1; i <= N; i++) { //N-1번 반복, N번째에는 사이클 판단, 계속 반복하면 음수 사이클때문에 무한 반복되기 때문
            for(int from = 1; from <= N; from++) {
                for(int k = 0 ; k < v[from].size(); k++) {
                    int to = v[from][k].first;
                    int cost = v[from][k].second;
                    
                    if(dist[to] > dist[from] + cost) {
                        dist[to] =  dist[from] + cost;
                        if(i==N) cycle = true;
                    }
                }
            }
        }
        
        if(cycle) cout << "YES\n";
        else cout << "NO\n";
        
    }
    
}


int main() {
    ios::sync_with_stdio(true); cin.tie(0); cout.tie(0);
    
    input();
    

    return 0;
}

원본링크 :
https://www.acmicpc.net/problem/1865

참고 문헌 : 
https://www.acmicpc.net/board/view/54167 //출발점 설정
https://www.acmicpc.net/board/view/50494 //inf 비교가 없는 이유
https://4z7l.github.io/2021/03/04/algorithms-boj-1865.html
