[Gold 3] 20303: 할로윈의 양아치
====================================  
[문제 링크](https://www.acmicpc.net/problem/20303)  

### 알고리즘 분류 :  
분리 집합, 배낭 문제, 다이나믹 프로그래밍  

### 시간 제한 :  
1초   

### 문제 설명 :  
Trick or Treat!!  
10월 31일 할로윈의 밤에는 거리의 여기저기서 아이들이 친구들과 모여 사탕을 받기 위해 돌아다닌다. 
올해 할로윈에도 어김없이 많은 아이가 할로윈을 즐겼지만 단 한 사람, 일찍부터 잠에 빠진 스브러스는 할로윈 밤을 즐길 수가 없었다. 
뒤늦게 일어나 사탕을 얻기 위해 혼자 돌아다녀 보지만 이미 사탕은 바닥나 하나도 얻을 수 없었다.  

단단히 화가 난 스브러스는 거리를 돌아다니며 다른 아이들의 사탕을 빼앗기로 마음을 먹는다. 다른 아이들보다 몸집이 큰 스브러스에게 사탕을 빼앗는 건 어렵지 않다. 
또한, 스브러스는 매우 공평한 사람이기 때문에 한 아이의 사탕을 뺏으면 그 아이 친구들의 사탕도 모조리 뺏어버린다. (친구의 친구는 친구다?!)  

사탕을 빼앗긴 아이들은 거리에 주저앉아 울고 K명 이상의 아이들이 울기 시작하면 울음소리가 공명하여 온 집의 어른들이 거리로 나온다. 
스브러스가 어른들에게 들키지 않고 최대로 뺏을 수 있는 사탕의 양을 구하여라.  
스브러스는 혼자 모든 집을 돌아다녔기 때문에 다른 아이들이 받은 사탕의 양을 모두 알고 있다. 또한, 모든 아이는 스브러스를 피해 갈 수 없다.   

### 입력 :   
첫째 줄에 정수 N,M,K가 주어진다. N은 거리에 있는 아이들의 수, M은 아이들의 친구 관계 수, K는 울음소리가 공명하기 위한 최소 아이의 수이다. (1 ≤ N ≤ 30,000,
0 ≤ M ≤ 100,000, 1 ≤ K ≤ min{N,3000})  
둘째 줄에는 아이들이 받은 사탕 수를 나타내는 정수 c<sub>1</sub>,c<sub>2</sub>,...,c<sub>N</sub> (1 ≤ c<sub>i</sub> ≤ 10,000)  
셋째 줄부터 M개 줄에 걸쳐 각각의 줄에 정수 a,b가 주어진다. 이는 a와 b가 친구임을 의미한다. 같은 친구 관계가 두 번 주어지는 경우는 없다. (1 ≤ a,b ≤ N, a≠b)  

### 출력 :   
스브러스가 어른들에게 들키지 않고 아이들로부터 뺏을 수 있는 최대 사탕의 수를 출력한다.  

-----------------------------------------------------------  
### 나의 해석 :  
친구의 친구는 친구다? -> 즉, 친구 관계가 엮인 같은 집합 내라면 사탕을 뺏길 때 같이 뺏긴다는 뜻이다.  
i번째를 루트로 하는 집합의 원소의 수를 저장하는 배열을 person[i], 뺏을 수 있는 사탕의 총 개수를 candy[i]라고 정의한다.  
분리 집합에서 합집합 union_find(x,y)를 진행할 때, 루트 x에 person[y], candy[y]를 더해주면 된다.  
  
친구 집합 계산을 마쳤으면 나머지는 배낭 문제처럼 해결하면 된다.  
dp[i][k] : i집합까지 선택하고, k명을 선택했을 때 얻을 수 있는 사탕의 최댓값  
위처럼 설정할 수 있지만, 최댓값을 갱신하는 과정에서는 이전의 정보만을 필요로 하기 때문에 dp[k]만을 이용하여 점화식을 구성한다.  
반복문을 설정할 때 j=K-1부터여야 하는데, K부터 시작하게 되면 문제 조건 중 K명이 울면 어른들에게 들키게 되므로 주의한다.  
dp[j] = max(dp[j], dp[j-person[i]] + candy[i]); 해당 점화식으로 문제를 해결할 수 있다.  

### 참고 문헌 :  
없음   

